<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Docker Compose in GitLab CI for integration tests | Bohumír Zámečník</title>
<link href="../../../assets/css/all.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://bohumirzamecnik.cz/blog/2018/gitlab-docker-compose-tests/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Bohumír Zámečník">
<link rel="prev" href="../../2016/krakow/" title="Poland - Kraków" type="text/html">
<meta property="og:site_name" content="Bohumír Zámečník">
<meta property="og:title" content="Docker Compose in GitLab CI for integration tests">
<meta property="og:url" content="https://bohumirzamecnik.cz/blog/2018/gitlab-docker-compose-tests/">
<meta property="og:description" content="How to run integrations tests in GitLab CI using nested Docker Compose and save artifacts? What looks trivial was a bit tricky. I wasted my time so you don't have to.


The story behind
At Rossum we b">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-08-17T00:00:00+02:00">
<meta property="article:tag" content="docker">
<meta property="article:tag" content="gitlab">
<meta property="article:tag" content="programming">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
            styles, `#sidebar-checkbox` for behavior. -->
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"><!-- Toggleable sidebar --><div class="sidebar" id="sidebar">

        <nav role="navigation" class="sidebar-nav"><a class="sidebar-nav-item" href="../../../"><i class="fa fa-2x fa-fw fa-home"></i> Home</a>
          <a class="sidebar-nav-item" href="../../"><i class="fa fa-2x fa-fw fa-user-circle"></i> Blog</a>
        </nav><nav id="menu" role="navigation" class="sidebar-nav"><a class="sidebar-nav-item" href="../../../about/">About</a>
        <a class="sidebar-nav-item" href="../../../projects/">Projects</a>
        <a class="sidebar-nav-item" href="../../../archive.html">Archive</a>
        <a class="sidebar-nav-item" href="../../../categories/">Tags</a>
        <a class="sidebar-nav-item" href="../../../rss.xml">RSS feed</a>
        <a class="sidebar-nav-item" href="https://github.com/bzamecnik/">GitHub</a>
        <a class="sidebar-nav-item" href="https://twitter.com/bzamecnik">Twitter</a>
        <a class="sidebar-nav-item" href="https://www.linkedin.com/in/bohumirzamecnik">LinkedIn</a>
        <a class="sidebar-nav-item" href="https://www.flickr.com/photos/elgriton/">Flickr</a>
        <a class="sidebar-nav-item" href="mailto:bohumir.zamecnik@gmail.com">E-mail</a>
    
    
    </nav>
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          
    <h2 id="brand" class="masthead-title">
      <a href="../../../" title="Bohumír Zámečník" rel="home">Bohumír Zámečník</a>
    </h2>

        </div>
      </div>

      <div class="container content" id="content">
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/BlogPosting"><header><h1 class="post-title p-name entry-title" itemprop="headline">
      <a href="https://bohumirzamecnik.cz/blog/2018/gitlab-docker-compose-tests/" class="u-url">Docker Compose in GitLab CI for integration tests</a>
</h1>
        <div class="metadata">
        <meta itemprop="inLanguage" content="en">
<p class="dateline">
            <time class="post-date published dt-published" datetime="2018-08-17T00:00:00+02:00" itemprop="datePublished" title="2018-08-17">2018-08-17</time></p>
                <p class="commentline">
        
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/2018/integration-tests-in-docker-compose-in-gitlab-ci.html">Comments</a>


        </p>
</div>
        

    </header><section class="e-content entry-content" itemprop="articleBody text"><div>
<p>How to run integrations tests in GitLab CI using nested Docker Compose and save artifacts? What looks trivial was a bit tricky. I wasted my time so you don't have to.</p>
<!-- TEASER_END -->

<h3>The story behind</h3>
<p>At <a href="https://rossum.ai">Rossum</a> we build our research and production code using GitLab CI. We use Docker to keep environments reproducible and easier to install. Recently I used Docker Compose to make an isolated dev environment for our prediction machine which consists of a Flask REST API, a worker, shared SQL database and S3 storage.</p>
<p>Soon after we had some glitch on production that passed manual testing and made some users unhappy. We quickly fixed that but realized we're afraid of deploying every release because we can break anything. The bug could have been easily found by integration tests. Yes, we need automated integration tests!</p>
<h3>Integration tests</h3>
<p>The Docker Compose stack for development came handy and I wrote a suite of tests that run prediction on known documents, validate the results and check for differences to previous expected results.</p>
<p>I found <a href="https://pypi.org/project/pytest-docker-compose/">pytest-docker-compose</a> plugin that runs Docker Compose stack as a fixture and provides it to individual unit tests. Very nice except that Python 2 is not supported anymore.</p>
<p>Instead I had to first run <code>docker-compose up</code>, then execute the tests in one of the containers, followed by <code>docker-compose down</code> in a shell script.</p>
<p>The docker-compose file for tests looks somehow like the following:</p>
<pre class="code literal-block"><span></span><span class="l l-Scalar l-Scalar-Plain">version</span><span class="p p-Indicator">:</span> <span class="s">'2.0'</span>

<span class="l l-Scalar l-Scalar-Plain">services</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">tests</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">image</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">${IMAGE}</span>
    <span class="l l-Scalar l-Scalar-Plain">command</span><span class="p p-Indicator">:</span> <span class="p p-Indicator">[</span>
      <span class="c1"># wait for the API for 5 seconds</span>
      <span class="s">"tools/wait-for-it.sh"</span><span class="p p-Indicator">,</span> <span class="s">"api:80"</span><span class="p p-Indicator">,</span> <span class="s">"-t"</span><span class="p p-Indicator">,</span> <span class="s">"5"</span><span class="p p-Indicator">,</span> <span class="s">"--"</span><span class="p p-Indicator">,</span>
      <span class="c1"># # -v (verbose), -s (show output), -x (stop at first failure)</span>
      <span class="s">"pytest"</span><span class="p p-Indicator">,</span> <span class="s">"-vsx"</span><span class="p p-Indicator">,</span> <span class="s">"tests/integration/api_integration_test.py"</span>
    <span class="p p-Indicator">]</span>
    <span class="l l-Scalar l-Scalar-Plain">environment</span><span class="p p-Indicator">:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">API_URL=http://api</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">ARTIFACTS_DIR</span>
    <span class="l l-Scalar l-Scalar-Plain">depends_on</span><span class="p p-Indicator">:</span>
      <span class="p p-Indicator">-</span> <span class="s">"api"</span>
      <span class="p p-Indicator">-</span> <span class="s">"worker"</span>
  <span class="l l-Scalar l-Scalar-Plain">db</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">image</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">custom-db-image</span>
    <span class="l l-Scalar l-Scalar-Plain">build</span><span class="p p-Indicator">:</span>
      <span class="l l-Scalar l-Scalar-Plain">context</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">.</span>
      <span class="l l-Scalar l-Scalar-Plain">dockerfile</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">Dockerfile.db.dev</span>
  <span class="l l-Scalar l-Scalar-Plain">api</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">image</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">${IMAGE}</span>
    <span class="l l-Scalar l-Scalar-Plain">command</span><span class="p p-Indicator">:</span> <span class="p p-Indicator">[</span>
      <span class="s">"tools/wait-for-it.sh"</span><span class="p p-Indicator">,</span> <span class="s">"db:5432"</span><span class="p p-Indicator">,</span> <span class="s">"-t"</span><span class="p p-Indicator">,</span> <span class="s">"60"</span><span class="p p-Indicator">,</span> <span class="s">"--"</span><span class="p p-Indicator">,</span>
      <span class="s">"uwsgi"</span><span class="p p-Indicator">,</span> <span class="s">"--yaml"</span><span class="p p-Indicator">,</span> <span class="s">"config/uwsgi.yml"</span><span class="p p-Indicator">,</span>
    <span class="p p-Indicator">]</span>
    <span class="l l-Scalar l-Scalar-Plain">depends_on</span><span class="p p-Indicator">:</span>
    <span class="p p-Indicator">-</span> <span class="s">"db"</span>
  <span class="l l-Scalar l-Scalar-Plain">worker</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">image</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">${IMAGE}</span>
    <span class="l l-Scalar l-Scalar-Plain">command</span><span class="p p-Indicator">:</span> <span class="p p-Indicator">[</span>
      <span class="s">"tools/wait-for-it.sh"</span><span class="p p-Indicator">,</span> <span class="s">"db:5432"</span><span class="p p-Indicator">,</span> <span class="s">"-t"</span><span class="p p-Indicator">,</span> <span class="s">"60"</span><span class="p p-Indicator">,</span> <span class="s">"--"</span><span class="p p-Indicator">,</span>
      <span class="s">"python"</span><span class="p p-Indicator">,</span> <span class="s">"worker.py"</span>
    <span class="p p-Indicator">]</span>
    <span class="l l-Scalar l-Scalar-Plain">depends_on</span><span class="p p-Indicator">:</span>
    <span class="p p-Indicator">-</span> <span class="s">"db"</span>
</pre>


<p>Note that we wait for the other services to be ready on given TCP port using the amazing <a href="https://github.com/vishnubob/wait-for-it">wait-for-it.sh</a> script and then run the tests via <code>pytest</code>. The test basically sends a request to the API service via our <a href="https://pypi.org/project/rossum/">client library</a> <code>rossum</code> (available on PyPI), then polls for the results using the <code>polling</code> package and then makes assertions on the JSON response.</p>
<p>The tests are inside a container for several reasons - common image containing our source code, python, pytest, dependecies, <code>wait-for-it.sh</code>, etc. (it could be better a separate small image); it can see the <code>api</code> service at <code>http://api:80</code> without binding to port on the host machine. Otherwise we'd have to select some random port to prevent conflicts.</p>
<blockquote>
<p>TIP: If you use AWS on GitLab CI we provide AWS credentials via env variables so we need to pass them though.</p>
</blockquote>
<pre class="code literal-block"><span></span><span class="l l-Scalar l-Scalar-Plain">some_job</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">environment</span><span class="p p-Indicator">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">AWS_ACCESS_KEY_ID</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">AWS_SECRET_ACCESS_KEY</span>
</pre>


<p>On my machine it worked well, now it was time for GitLab CI automation.</p>
<h3>Docker in GitLab CI</h3>
<p>We already use Docker executor in our GitLab runners. Typically in the workflow we build an image, run tests with that image and then either clean up or push the released images to our Docker repository. In this case we need to run <code>docker-compose</code> to start new containers and execute tests in one of them.</p>
<p>There are two options - Docker-in-Docker or using shared docker deamon. In the first case the GitLab CI job container provides it's own docker deamon and runs all the containers nested. In the latter case (that we use) all the containers are siblings and just share the same deamon (via mounted socket <code>/var/run/docker.sock</code>).</p>
<p>Using standard <code>docker:latest</code> image with <code>docker-compose</code>, <code>pip</code>, <code>bash</code> and <code>git</code> installed in addition we can run our Docker Compose stack easily.</p>
<pre class="code literal-block"><span></span><span class="c1"># .gitlab-ci.yml</span>

<span class="l l-Scalar l-Scalar-Plain">stages</span><span class="p p-Indicator">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">build</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">test</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">cleanup</span>

<span class="l l-Scalar l-Scalar-Plain">variables</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">IMAGE</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">foobar:${CI_COMMIT_SHA}</span>

<span class="l l-Scalar l-Scalar-Plain">build-image</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">stage</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">build</span>
  <span class="l l-Scalar l-Scalar-Plain">image</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">docker:latest</span>
  <span class="l l-Scalar l-Scalar-Plain">script</span><span class="p p-Indicator">:</span>
    <span class="p p-Indicator">-</span> <span class="p p-Indicator">&gt;</span>
      <span class="no">docker build</span>
      <span class="no">-f Dockerfile</span>
      <span class="no">-t ${IMAGE}</span>
      <span class="no">--pull .</span>

<span class="l l-Scalar l-Scalar-Plain">test-api-integration</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">stage</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">test</span>
  <span class="l l-Scalar l-Scalar-Plain">image</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">docker:latest</span>
  <span class="l l-Scalar l-Scalar-Plain">before_script</span><span class="p p-Indicator">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">apk add --no-cache py-pip bash git</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">pip install docker-compose</span>
  <span class="l l-Scalar l-Scalar-Plain">script</span><span class="p p-Indicator">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">tests/integration/test_api_integration.sh</span>

<span class="l l-Scalar l-Scalar-Plain">cleanup</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">stage</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">cleanup</span>
  <span class="l l-Scalar l-Scalar-Plain">when</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">always</span>
  <span class="l l-Scalar l-Scalar-Plain">script</span><span class="p p-Indicator">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">docker rmi ${IMAGE} || true</span>
</pre>


<p>The basic test runner would look like this:</p>
<pre class="code literal-block"><span></span><span class="ch">#!/usr/bin/env bash</span>

<span class="c1"># tests/integration/test_api_integration.sh</span>
<span class="c1"># Print commands</span>
<span class="nb">set</span> -x

<span class="c1"># Make the container names unique</span>
<span class="nb">export</span> <span class="nv">COMPOSE_PROJECT_NAME</span><span class="o">=</span><span class="k">$(</span>git rev-parse --short HEAD<span class="k">)</span>

<span class="c1"># the docker-compose file uses $IMAGE to set the project image</span>
<span class="nv">docker_compose_cmd</span><span class="o">=</span><span class="s2">"docker-compose -f docker-compose.api.test.yml"</span>
<span class="si">${</span><span class="nv">docker_compose_cmd</span><span class="si">}</span> build
<span class="c1"># Run service containers, except for test container</span>
<span class="si">${</span><span class="nv">docker_compose_cmd</span><span class="si">}</span> up -d --no-deps db api worker

<span class="c1"># Run the tests</span>
<span class="si">${</span><span class="nv">docker_compose_cmd</span><span class="si">}</span> run --rm tests

<span class="c1"># Clean up</span>
<span class="si">${</span><span class="nv">docker_compose_cmd</span><span class="si">}</span> down
</pre>


<h3>Exit code</h3>
<p>The above code runs the tests but always succeeds. The thing is that GitLab CI test jobs fail when the last command given non-zero exit code. It fails on first such command.</p>
<p>The <code>tests</code> container executes the python test file via <code>pytest</code> and exits with zero on success and non-zero on test failure. If we put the commands from the script directly to <code>.gilab-ci.yml</code> it would stop at the test command and never stop the dependent containers! The default in the bash script is to continue after a non-zero exit code. But the script itself returns the exit code of the last command.</p>
<p>What we want is to save the test exit code and return it at the end of the script.</p>
<pre class="code literal-block"><span></span><span class="c1"># tests/integration/test_api_integration.sh</span>
<span class="c1"># [...]</span>

<span class="c1"># Run the tests</span>
<span class="si">${</span><span class="nv">docker_compose_cmd</span><span class="si">}</span> run --rm tests

<span class="c1"># keep the exit code from tests while we clean up the containers</span>
<span class="nv">exit_code</span><span class="o">=</span><span class="nv">$?</span>

<span class="c1"># Clean up</span>
<span class="si">${</span><span class="nv">docker_compose_cmd</span><span class="si">}</span> down

<span class="c1"># return the original result of the test - for GitLab CI</span>
<span class="nb">exit</span> <span class="si">${</span><span class="nv">exit_code</span><span class="si">}</span>
</pre>


<p>Possibly we could just turn off failing on the first error <code>set +e</code> (<a href="https://www.davidpashley.com/articles/writing-robust-shell-scripts/">more info</a>) in <code>.gitlab-ci.yml</code> but I find cleaner to have a separate script that can be ran separately from GitLab.</p>
<blockquote>
<p>TIP: In case of failure we can print the logs from the api and worker containers (before <code>docker-compose down</code>):</p>
</blockquote>
<pre class="code literal-block"><span></span><span class="c1"># report what happened wrong</span>
<span class="k">if</span> <span class="o">[</span> <span class="si">${</span><span class="nv">exit_code</span><span class="si">}</span> -ne <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="si">${</span><span class="nv">docker_compose_cmd</span><span class="si">}</span> logs api
    <span class="si">${</span><span class="nv">docker_compose_cmd</span><span class="si">}</span> logs worker
<span class="k">fi</span>
</pre>


<h3>Artifacts</h3>
<p>Originally I wrote a pure regression test comparing current JSON outputs to previous ones, known to be good. It can report any mistake, but also fail on every slight change due to differently trained model. In the second iteration I just wrote a <a href="http://json-schema.org/">JSON schema</a> for our API responses and validated againt it. Also the tests now make only a warning on non-empty JSON diff. For these tasks I recommend packages <a href="https://github.com/Julian/jsonschema">jsonchema</a> and <a href="https://github.com/ZoomerAnalytics/jsondiff">jsondiff</a>.</p>
<p>Still, when we release a new feature and check the changes are as expected we want to fix the new results as expected. For that we'd like just to reuse what has been already computed (not to run any long computations again manually).</p>
<p>In other words we'd like our API test to produce and artifact - ideally a ZIP file containing a set of predicted JSONs that we can commit back to the repo (and as a bonus the JSON diffs to keep for reference).</p>
<p>GitLab CI allows jobs to store build artifact (such as compiled binaries or test results) so we can use this feature.</p>
<p>In <code>.gitlab-ci.yml</code> we can specify the path from where to copy the files, name of the resulting ZIP file, when to store (we want both after success an failure) and how long to keep them.</p>
<pre class="code literal-block"><span></span><span class="c1"># .gitlab-ci.yml</span>

<span class="l l-Scalar l-Scalar-Plain">test-api-integration</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">stage</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">test</span>
  <span class="l l-Scalar l-Scalar-Plain">image</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">docker:latest</span>
  <span class="l l-Scalar l-Scalar-Plain">before_script</span><span class="p p-Indicator">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">apk add --no-cache py-pip bash</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">pip install docker-compose</span>
  <span class="l l-Scalar l-Scalar-Plain">script</span><span class="p p-Indicator">:</span>
    <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">tests/integration/test_api_integration.sh</span>
  <span class="l l-Scalar l-Scalar-Plain">artifacts</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">name</span><span class="p p-Indicator">:</span> <span class="s">"api_test_artifacts_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA}"</span>
    <span class="l l-Scalar l-Scalar-Plain">paths</span><span class="p p-Indicator">:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">build/api_tests/</span>
    <span class="l l-Scalar l-Scalar-Plain">expire_in</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">7 days</span>
    <span class="l l-Scalar l-Scalar-Plain">when</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">always</span>
</pre>


<p>Now to question is how to get the test output files to the GitLab job container.</p>
<p>For me it was a long painful trial-and-error journey to get this working. And the happiness when it finally started working was thus higher.</p>
<h4>What does not work</h4>
<ul>
<li>The output files are in the <code>tests</code> container, not the <code>job</code> container, we need to transfer them.</li>
<li>The source code is in an anonymous volume mounted in the <code>job</code> container, not at the host machine (actually it is but buried deep down in Docker <code>/var</code>).</li>
<li>When mounting volume with source path in <code>job</code> container to the <code>tests</code> container the source path is at the host machine, not in the container! This is not Docker-in-Docker, they're siblings.</li>
<li>We cannot add a new volume to the alredy running <code>job</code> container, except if we mount a global named volume to all containers (in GitLab's <code>config.toml</code>). Not our way.</li>
<li>What worked when running a single container is <code>docker run --volumes-from $PARENT_CONTAINER_ID</code> (<a href="https://gitlab.com/gitlab-org/gitlab-runner/issues/1389">idea from the docker fora</a>). This is in <code>docker-compose.yml</code> as <a href="https://docs.docker.com/compose/compose-file/compose-file-v2/#volumes_from">volumes_from</a>, but not optional. We need to run the tests also by hand, not nested in other container.</li>
</ul>
<p>My friends:</p>
<ul>
<li><a href="https://docs.docker.com/compose/compose-file/compose-file-v2/">Docker Compose docs</a></li>
<li><a href="https://docs.gitlab.com/ce/user/project/pipelines/job_artifacts.html">GitLab CI Artifacts docs</a></li>
<li>
<code>debugfs</code> - <a href="https://unix.stackexchange.com/questions/35292/quickly-find-which-files-belongs-to-a-specific-inode-number">given an inode find path on the filesystem</a><ul>
<li>allows to track a file in container where is actually located on the host machine</li>
<li>
<code>ls -lai some_file</code> -&gt; inode</li>
<li>
<code>sudo debugfs -R 'ncheck 1234567' /dev/sda2</code> - to find path for inode <code>1234567</code> on partition <code>/dev/sda2</code>
</li>
</ul>
</li>
</ul>
<h4>What worked</h4>
<p>After GitLab gave me some lectures of how containers in it actually work I found the only way is to mount existing volume with the source code from the "parent" <code>job</code> container to the "nested" <code>tests</code> container. We do it via an optional docker-compose file, since in case of running the tests locally we want to mount another volume for artifacts from local filesystem.</p>
<p>TIP: The trick to get id of current container <a href="https://stackoverflow.com/questions/34496882/get-docker-container-id-from-container-name">source</a> is:</p>
<pre class="code literal-block"><span></span>basename "$(cat /proc/1/cpuset)"| cut -c 1-12
</pre>


<p>Now the working way to mount the parent volume to the nested container:</p>
<pre class="code literal-block"><span></span><span class="c1"># .gitlab-ci.yml</span>
<span class="l l-Scalar l-Scalar-Plain">test-api-integration</span><span class="p p-Indicator">:</span>
  <span class="c1"># ...</span>
  <span class="l l-Scalar l-Scalar-Plain">before_script</span><span class="p p-Indicator">:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">export ARTIFACTS_DIR="$(pwd)/build/api_tests/"</span>
    <span class="l l-Scalar l-Scalar-Plain"># Causes to mount existing volume with source codes to store artifacts.</span>
    <span class="l l-Scalar l-Scalar-Plain"># (We can't add another named volume to this container.)</span>
    <span class="l l-Scalar l-Scalar-Plain">- export PARENT_CONTAINER_ID=$(basename "$(cat /proc/1/cpuset)"| cut -c 1-12)</span>
  <span class="c1"># ...</span>
</pre>


<p>The optional docker-compose file with <code>volumes_from</code>. note the <code>container:</code> prefix - this is a different to plain <code>docker run</code>.</p>
<pre class="code literal-block"><span></span><span class="l l-Scalar l-Scalar-Plain">version</span><span class="p p-Indicator">:</span> <span class="s">'2.0'</span>

<span class="l l-Scalar l-Scalar-Plain">services</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">tests</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">volumes_from</span><span class="p p-Indicator">:</span>
      <span class="c1"># Mounting volumes from parent container to nested one</span>
      <span class="c1"># so that we could store artifacts.</span>
      <span class="c1"># Unfortunately `docker-compose run` doesn't support `--volumes-from`</span>
      <span class="c1"># (https://github.com/docker/compose/issues/1769) and we want to have</span>
      <span class="c1"># it optional (for manual invocation of tests).</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">container:$PARENT_CONTAINER_ID</span>
</pre>


<p>And the test runner script:</p>
<pre class="code literal-block"><span></span><span class="c1"># tests_api_integration.sh</span>

<span class="c1"># - PARENT_CONTAINER_ID - (optional) id of parent container to mount its volumes</span>
<span class="c1">#   - this can be filled when running tests in nested container in GitLab CI</span>
<span class="c1">#   - and empty otherwise</span>
<span class="c1"># - ARTIFACTS_DIR - directory with artifacts at the host and tests container</span>
<span class="c1">#   - you can leave it to the default</span>
<span class="c1">#   - if PARENT_CONTAINER_ID is set, ARTIFACTS_DIR must be available at its mounted volumes</span>

<span class="c1"># [...]</span>

<span class="nv">docker_compose_cmd</span><span class="o">=</span><span class="s2">"docker-compose -f docker-compose.api.test.yml"</span>

<span class="c1"># Mount the volume with source codes from parent container where that artifacts should be stored to.</span>
<span class="c1"># For a nested container in GitLab CI the source volume path is relative in the docker daemon fs!</span>
<span class="c1"># If ARTIFACTS_DIR is not set, this will set it to default value.</span>
mkdir -p <span class="si">${</span><span class="nv">ARTIFACTS_DIR</span><span class="p">:=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">/build/api_tests/"</span><span class="si">}</span>

<span class="k">if</span> <span class="o">[</span> ! -z <span class="si">${</span><span class="nv">PARENT_CONTAINER_ID</span><span class="si">}</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c1"># for invocation in GitLab CI within a nested container</span>
    <span class="nv">docker_compose_cmd</span><span class="o">=</span><span class="s2">"</span><span class="nv">$docker_compose_cmd</span><span class="s2"> -f docker-compose.api.test.gitlab.yml"</span>
    <span class="nv">MOUNT_ARTIFACT_VOLUME</span><span class="o">=</span><span class="s2">""</span>
<span class="k">else</span>
    <span class="c1"># for manual invocation</span>
    <span class="nv">MOUNT_ARTIFACT_VOLUME</span><span class="o">=</span><span class="s2">"-v </span><span class="si">${</span><span class="nv">ARTIFACTS_DIR</span><span class="si">}</span><span class="s2">:</span><span class="si">${</span><span class="nv">ARTIFACTS_DIR</span><span class="si">}</span><span class="s2">"</span>
<span class="k">fi</span>

<span class="nb">echo</span> <span class="s2">"MOUNT_ARTIFACT_VOLUME: </span><span class="si">${</span><span class="nv">MOUNT_ARTIFACT_VOLUME</span><span class="si">}</span><span class="s2">"</span>

<span class="c1"># Run the tests and keep the exit code.</span>
<span class="si">${</span><span class="nv">docker_compose_cmd</span><span class="si">}</span> run --rm <span class="si">${</span><span class="nv">MOUNT_ARTIFACT_VOLUME</span><span class="si">}</span> tests

<span class="c1"># [...]</span>
</pre>


<p>Then the test stores the output files into the directory provided in <code>$ARTIFACTS_DIR</code> and the job container sees them.</p>
<p>The artifact files can be then listed in GitLab CI job page and downloaded together as a ZIP file.</p>
<h3>Manual invocation</h3>
<p>A nice thing is we can also run the test suite manually outside of GitLab (eg. on some more powerful machine or a poor MacBook):</p>
<pre class="code literal-block"><span></span><span class="nb">export</span> <span class="nv">IMAGE</span><span class="o">=</span>foobar:<span class="k">$(</span>git rev-parse --short HEAD<span class="k">)</span>-test
docker build -f Dockerfile -t <span class="si">${</span><span class="nv">IMAGE</span><span class="si">}</span> --pull .
tests/integration/test_api_integration.sh
<span class="c1"># check the artifacts (extracted JSONs and differences to expected ones)</span>
find build/api_tests/
</pre>


<h3>Conclusion</h3>
<p>It took some time to set up but now we're able to run tests of integration of our REST API and woker via database, validate the resulting JSONs and compare with previous results. Now it might be good to optimize the tests.</p>
<p>Possibly if we took the time, build a separate image where tests can run directly in the job container we could save time of hacking how to obtain the artifacts.</p>
<p>&lt;ad&gt;Btw: If you need to reduce manual data entry work and automate extracting data from invoices check <a href="https://rossum.ai">Rossum</a> and its new <a href="https://rossum.ai/developers">Elis Data Extraction API</a> (our baby we're working hard to improve) that enables you to extract up to 300 invoices/month for free using some quite good machine learning.&lt;/ad&gt;</p>
<p>Stay tuned for more stories and tutorials from our research and development.</p>
</div>
    </section><aside class="sharing no-print"><a href="#content" aria-label="Post beginning">
       <i class="fa fa-2x fa-fw fa-arrow-circle-up" aria-hidden="true" title="Post beginning"></i>
    </a>
    <a href="https://bohumirzamecnik.cz/blog/2016/krakow/" rel="prev" title="Poland - Kraków">
       <i class="fa fa-2x fa-fw fa-arrow-circle-left" aria-hidden="true" title="Previous post: Poland - Kraków"></i>
    </a>
    <span class="post-sharing">
     <a href="http://twitter.com/share?text=Docker+Compose+in+GitLab+CI+for+integration+tests&amp;url=https%3A%2F%2Fbohumirzamecnik.cz%2Fblog%2F2018%2Fgitlab-docker-compose-tests%2F" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" aria-label="Share on Twitter">
       <i class="fa fa-2x fa-fw fa-twitter-square" aria-hidden="true" title="Share on Twitter">
     </i></a>
     <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fbohumirzamecnik.cz%2Fblog%2F2018%2Fgitlab-docker-compose-tests%2F" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;" aria-label="Share on Facebook">
       <i class="fa fa-2x fa-fw fa-facebook-square" style="margin-left: -8px" aria-hidden="true" title="Share of Facebook">
     </i></a>
     <a href="https://plus.google.com/share?url=https%3A%2F%2Fbohumirzamecnik.cz%2Fblog%2F2018%2Fgitlab-docker-compose-tests%2F" aria-label="Share on Google+" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
       <i class="fa fa-2x fa-fw fa-google-plus-square" style="margin-left: -8px" aria-hidden="true" title="Share on Google+">
     </i></a>
     </span>
</aside><div itemprop="author" itemscope itemtype="http://schema.org/Person">


        <section class="comments hidden-print"><h2>Comments</h2>
        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="bzamecnik",
            disqus_url="https://bohumirzamecnik.cz/blog/2018/gitlab-docker-compose-tests/",
        disqus_title="Docker Compose in GitLab CI for integration tests",
        disqus_identifier="cache/posts/2018/integration-tests-in-docker-compose-in-gitlab-ci.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section><script>var disqus_shortname="bzamecnik";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><footer id="footer"><p>
© 2018 <a href="mailto:bohumir.zamecnik@gmail.com">Bohumír Zámečník</a>
- Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a>,
theme based on: <a href="https://themes.getnikola.com/v7/jidn/">jidn</a>
/ <a href="https://github.com/poole/lanyon">lanyon</a>

</p>
            
        </footer>
</div>
    </article>
</div>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-44857522-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script><script src="../../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</div>
</body>
</html>
